{
  "apiInfo": {
    "version": "2.0.0",
    "title": "PDF Translation & RAG API",
    "description": "PDF OCR、翻譯、圖片翻譯與多模態 RAG 服務。支援 Flutter 手機端、Web 端與 React 前端整合。",
    "baseUrlExample": "http://localhost:8000",
    "supportedClients": ["Flutter (Mobile/Web)", "React", "任何支援 REST API 的前端框架"]
  },

  "authentication": {
    "type": "Bearer Token (Supabase JWT)",
    "header": "Authorization",
    "headerFormat": "Bearer {supabase_access_token}",
    "description": "所有受保護的端點都需要 Supabase JWT Token。前端需要先透過 Supabase Auth 登入後取得 access_token。",
    "exampleHeader": {
      "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    },
    "notes": [
      "Token 需從 Supabase Auth 登入後取得",
      "Flutter: 使用 supabase_flutter 套件的 supabase.auth.currentSession?.accessToken",
      "React: 使用 @supabase/supabase-js 的 session.access_token",
      "Token 過期需重新取得或使用 refresh_token 刷新",
      "開發模式 (DEV_MODE=true) 可跳過認證，僅供測試用"
    ],
    "errorResponses": {
      "401": {
        "detail": "Missing Authorization Header | Invalid Authorization Header format | Invalid Token | Authentication Failed"
      },
      "500": {
        "detail": "Authentication service unavailable (Supabase 連線問題)"
      }
    }
  },

  "endpoints": {
    "health": {
      "path": "/",
      "method": "GET",
      "description": "健康檢查端點，確認 API 服務是否正常運作",
      "authentication": false,
      "request": null,
      "response": {
        "type": "object",
        "example": {
          "message": "Welcome to the PDF Translation & Per-User RAG QA API."
        }
      },
      "flutterExample": "final response = await http.get(Uri.parse('$baseUrl/'));",
      "reactExample": "const response = await fetch(`${baseUrl}/`);"
    },

    "pdfmd": {
      "prefix": "/pdfmd",
      "description": "PDF OCR & 翻譯服務",
      "endpoints": {
        "upload_pdf": {
          "path": "/pdfmd/ocr",
          "method": "POST",
          "description": "上傳 PDF 文件，進行 OCR 辨識後翻譯成繁體中文，並加入 RAG 知識庫",
          "authentication": true,
          "request": {
            "contentType": "multipart/form-data",
            "parameters": {
              "file": {
                "type": "file",
                "required": true,
                "description": "PDF 檔案 (必須是 application/pdf)"
              }
            }
          },
          "response": {
            "type": "FileResponse",
            "contentType": "application/pdf",
            "description": "翻譯後的 PDF 檔案",
            "headers": {
              "Content-Disposition": "attachment; filename=translated_{doc_id}.pdf"
            }
          },
          "pipeline": [
            "1. 儲存上傳的 PDF",
            "2. OCR 辨識 (PaddleOCR - GPU 加速)",
            "3. 翻譯內容為繁體中文 (Gemini LLM)",
            "4. 加入 RAG 知識庫 (FAISS 向量索引)",
            "5. 生成翻譯後的 PDF 並回傳"
          ],
          "errorResponses": {
            "400": "Invalid file type | 不支援的檔案格式",
            "500": "OCR failed | Translation failed | PDF generation failed"
          },
          "flutterExample": {
            "code": "import 'package:http/http.dart' as http;\nimport 'package:http_parser/http_parser.dart';\n\nFuture<Uint8List> uploadPdf(File pdfFile, String accessToken) async {\n  final uri = Uri.parse('$baseUrl/pdfmd/ocr');\n  final request = http.MultipartRequest('POST', uri)\n    ..headers['Authorization'] = 'Bearer $accessToken'\n    ..files.add(await http.MultipartFile.fromPath(\n      'file',\n      pdfFile.path,\n      contentType: MediaType('application', 'pdf'),\n    ));\n  \n  final response = await request.send();\n  if (response.statusCode == 200) {\n    return await response.stream.toBytes();\n  }\n  throw Exception('Upload failed: ${response.statusCode}');\n}"
          },
          "reactExample": {
            "code": "async function uploadPdf(file: File, accessToken: string): Promise<Blob> {\n  const formData = new FormData();\n  formData.append('file', file);\n  \n  const response = await fetch(`${baseUrl}/pdfmd/ocr`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n    },\n    body: formData,\n  });\n  \n  if (!response.ok) throw new Error(`Upload failed: ${response.status}`);\n  return response.blob();\n}"
          },
          "notes": [
            "處理時間較長 (視 PDF 頁數而定)，建議顯示載入指示器",
            "大檔案建議設定較長的 timeout (60秒以上)",
            "回傳的是二進位 PDF 檔案，需用 Blob/Uint8List 處理"
          ]
        },
        
        "get_pdf_file": {
          "path": "/pdfmd/file/{doc_id}",
          "method": "GET",
          "description": "透過文件 ID 取得已處理的 PDF 檔案",
          "authentication": true,
          "request": {
            "pathParameters": {
              "doc_id": {
                "type": "string",
                "format": "uuid",
                "required": true,
                "description": "文件的 UUID"
              }
            }
          },
          "response": {
            "type": "FileResponse",
            "contentType": "application/pdf",
            "description": "PDF 檔案"
          },
          "errorResponses": {
            "404": "Document not found | 文件不存在或已被刪除"
          },
          "flutterExample": {
            "code": "Future<Uint8List> getPdfFile(String docId, String accessToken) async {\n  final response = await http.get(\n    Uri.parse('$baseUrl/pdfmd/file/$docId'),\n    headers: {'Authorization': 'Bearer $accessToken'},\n  );\n  if (response.statusCode == 200) return response.bodyBytes;\n  throw Exception('Not found: ${response.statusCode}');\n}"
          },
          "reactExample": {
            "code": "async function getPdfFile(docId: string, accessToken: string): Promise<Blob> {\n  const response = await fetch(`${baseUrl}/pdfmd/file/${docId}`, {\n    headers: { 'Authorization': `Bearer ${accessToken}` },\n  });\n  if (!response.ok) throw new Error('Not found');\n  return response.blob();\n}"
          }
        },
        
        "delete_pdf_file": {
          "path": "/pdfmd/file/{doc_id}",
          "method": "DELETE",
          "description": "刪除文件及其所有相關資料（RAG 索引、實體檔案、資料庫記錄）",
          "authentication": true,
          "request": {
            "pathParameters": {
              "doc_id": {
                "type": "string",
                "format": "uuid",
                "required": true,
                "description": "文件的 UUID"
              }
            }
          },
          "response": {
            "type": "object",
            "example": {
              "status": "success",
              "message": "Document deleted successfully"
            }
          },
          "cleanupSteps": [
            "1. 從 FAISS 向量索引中移除",
            "2. 刪除實體檔案 (原始 PDF + 翻譯 PDF)",
            "3. 移除 Supabase 資料庫記錄"
          ],
          "errorResponses": {
            "500": "Database deletion failed"
          },
          "flutterExample": {
            "code": "Future<void> deletePdf(String docId, String accessToken) async {\n  final response = await http.delete(\n    Uri.parse('$baseUrl/pdfmd/file/$docId'),\n    headers: {'Authorization': 'Bearer $accessToken'},\n  );\n  if (response.statusCode != 200) {\n    throw Exception('Delete failed');\n  }\n}"
          }
        }
      }
    },

    "rag": {
      "prefix": "/rag",
      "description": "RAG 問答服務 - 基於使用者知識庫的智能問答",
      "endpoints": {
        "ask_question": {
          "path": "/rag/ask",
          "method": "GET",
          "description": "使用 RAG 回答問題，可選擇性指定查詢的文件範圍",
          "authentication": true,
          "request": {
            "queryParameters": {
              "question": {
                "type": "string",
                "required": true,
                "description": "要問的問題"
              },
              "doc_ids": {
                "type": "string",
                "required": false,
                "description": "逗號分隔的文件 ID，用於過濾查詢範圍。留空則查詢所有文件。",
                "example": "uuid1,uuid2,uuid3"
              }
            }
          },
          "response": {
            "type": "AnswerResponse",
            "schema": {
              "question": {
                "type": "string",
                "description": "原始問題"
              },
              "answer": {
                "type": "string",
                "description": "AI 生成的答案"
              },
              "sources": {
                "type": "array",
                "items": "string",
                "description": "回答所參考的文件 ID 列表"
              }
            },
            "example": {
              "question": "什麼是機器學習?",
              "answer": "機器學習是人工智慧的一個分支...",
              "sources": ["doc-uuid-1", "doc-uuid-2"]
            }
          },
          "errorResponses": {
            "500": "Failed to answer question"
          },
          "flutterExample": {
            "code": "Future<AnswerResponse> askQuestion(\n  String question,\n  String accessToken, {\n  List<String>? docIds,\n}) async {\n  final queryParams = {'question': question};\n  if (docIds != null && docIds.isNotEmpty) {\n    queryParams['doc_ids'] = docIds.join(',');\n  }\n  \n  final uri = Uri.parse('$baseUrl/rag/ask').replace(queryParameters: queryParams);\n  final response = await http.get(\n    uri,\n    headers: {'Authorization': 'Bearer $accessToken'},\n  );\n  \n  if (response.statusCode == 200) {\n    return AnswerResponse.fromJson(jsonDecode(response.body));\n  }\n  throw Exception('Ask failed: ${response.statusCode}');\n}"
          },
          "reactExample": {
            "code": "async function askQuestion(\n  question: string,\n  accessToken: string,\n  docIds?: string[]\n): Promise<AnswerResponse> {\n  const params = new URLSearchParams({ question });\n  if (docIds?.length) params.set('doc_ids', docIds.join(','));\n  \n  const response = await fetch(`${baseUrl}/rag/ask?${params}`, {\n    headers: { 'Authorization': `Bearer ${accessToken}` },\n  });\n  \n  if (!response.ok) throw new Error('Ask failed');\n  return response.json();\n}"
          },
          "notes": [
            "使用 GET 方法，問題透過 Query Parameter 傳遞",
            "doc_ids 可用於限制查詢特定文件（適合文件對話場景）",
            "建議 URL encode question 參數以處理特殊字元"
          ]
        },

        "research_question": {
          "path": "/rag/research",
          "method": "POST",
          "description": "深度研究模式 - 使用 Plan-and-Solve 將複雜問題拆解為子任務，分別進行 RAG 查詢後綜合答案",
          "authentication": true,
          "request": {
            "contentType": "application/json",
            "body": {
              "question": {
                "type": "string",
                "required": true,
                "description": "要研究的複雜問題"
              },
              "max_subtasks": {
                "type": "integer",
                "required": false,
                "default": 5,
                "description": "最大子任務數量 (1-10)"
              },
              "enable_reranking": {
                "type": "boolean",
                "required": false,
                "default": true,
                "description": "是否啟用重排序優化結果"
              }
            },
            "example": {
              "question": "比較深度學習和傳統機器學習的優缺點",
              "max_subtasks": 5,
              "enable_reranking": true
            }
          },
          "response": {
            "type": "ResearchResponse",
            "schema": {
              "question": {
                "type": "string",
                "description": "原始問題"
              },
              "summary": {
                "type": "string",
                "description": "研究結果摘要"
              },
              "detailed_answer": {
                "type": "string",
                "description": "詳細的研究報告"
              },
              "sub_tasks": {
                "type": "array",
                "description": "子任務及其答案",
                "items": {
                  "id": "integer",
                  "question": "string",
                  "answer": "string",
                  "sources": "array[string]"
                }
              },
              "all_sources": {
                "type": "array",
                "items": "string",
                "description": "所有參考的文件 ID"
              },
              "confidence": {
                "type": "number",
                "description": "答案信心度 (0.0 - 1.0)"
              }
            }
          },
          "errorResponses": {
            "500": "Research failed"
          },
          "flutterExample": {
            "code": "Future<ResearchResponse> researchQuestion(\n  String question,\n  String accessToken, {\n  int maxSubtasks = 5,\n  bool enableReranking = true,\n}) async {\n  final response = await http.post(\n    Uri.parse('$baseUrl/rag/research'),\n    headers: {\n      'Authorization': 'Bearer $accessToken',\n      'Content-Type': 'application/json',\n    },\n    body: jsonEncode({\n      'question': question,\n      'max_subtasks': maxSubtasks,\n      'enable_reranking': enableReranking,\n    }),\n  );\n  \n  if (response.statusCode == 200) {\n    return ResearchResponse.fromJson(jsonDecode(response.body));\n  }\n  throw Exception('Research failed');\n}"
          },
          "reactExample": {
            "code": "async function researchQuestion(\n  question: string,\n  accessToken: string,\n  options?: { maxSubtasks?: number; enableReranking?: boolean }\n): Promise<ResearchResponse> {\n  const response = await fetch(`${baseUrl}/rag/research`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      question,\n      max_subtasks: options?.maxSubtasks ?? 5,\n      enable_reranking: options?.enableReranking ?? true,\n    }),\n  });\n  \n  if (!response.ok) throw new Error('Research failed');\n  return response.json();\n}"
          },
          "notes": [
            "適合複雜、需要多角度分析的問題",
            "處理時間較長 (需多次 LLM 呼叫)，建議設定較長 timeout",
            "回傳包含完整的子任務分析過程，適合呈現研究報告",
            "confidence 值可用於判斷答案可靠度"
          ]
        }
      }
    },

    "imagemd": {
      "prefix": "/imagemd",
      "description": "圖片翻譯服務 - 原地翻譯圖片中的文字",
      "endpoints": {
        "translate_image": {
          "path": "/imagemd/translate_image",
          "method": "POST",
          "description": "辨識圖片中的文字並翻譯，將翻譯後的文字覆蓋回原圖相同位置",
          "authentication": true,
          "request": {
            "contentType": "multipart/form-data",
            "parameters": {
              "file": {
                "type": "file",
                "required": true,
                "allowedTypes": ["image/jpeg", "image/png", "image/webp"],
                "allowedExtensions": [".jpg", ".jpeg", ".png", ".webp"],
                "description": "要翻譯的圖片檔案"
              }
            }
          },
          "response": {
            "type": "Image (bytes)",
            "contentType": "image/jpeg",
            "description": "翻譯後的圖片（JPEG 格式）"
          },
          "pipeline": [
            "1. 讀取並驗證圖片",
            "2. OCR 辨識文字區塊",
            "3. 翻譯偵測到的文字為繁體中文",
            "4. 將翻譯文字繪製回原圖對應位置",
            "5. 回傳修改後的圖片"
          ],
          "errorResponses": {
            "400": "Unsupported image type | Invalid image extension | Invalid or corrupted image file",
            "500": "Image translation failed"
          },
          "flutterExample": {
            "code": "Future<Uint8List> translateImage(File imageFile, String accessToken) async {\n  final uri = Uri.parse('$baseUrl/imagemd/translate_image');\n  final request = http.MultipartRequest('POST', uri)\n    ..headers['Authorization'] = 'Bearer $accessToken'\n    ..files.add(await http.MultipartFile.fromPath(\n      'file',\n      imageFile.path,\n      contentType: MediaType('image', 'jpeg'),\n    ));\n  \n  final response = await request.send();\n  if (response.statusCode == 200) {\n    return await response.stream.toBytes();\n  }\n  throw Exception('Translation failed');\n}"
          },
          "reactExample": {
            "code": "async function translateImage(file: File, accessToken: string): Promise<Blob> {\n  const formData = new FormData();\n  formData.append('file', file);\n  \n  const response = await fetch(`${baseUrl}/imagemd/translate_image`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${accessToken}` },\n    body: formData,\n  });\n  \n  if (!response.ok) throw new Error('Translation failed');\n  return response.blob();\n}"
          },
          "notes": [
            "回傳的圖片為 JPEG 格式",
            "若圖片中沒有偵測到文字，會回傳原圖",
            "翻譯文字會嘗試保持原有字體大小和位置"
          ]
        }
      }
    },

    "multimodal": {
      "prefix": "/multimodal",
      "description": "多模態 RAG 服務 - 提取 PDF 中的文字和視覺元素（圖表、公式）並建立索引",
      "endpoints": {
        "extract": {
          "path": "/multimodal/extract",
          "method": "POST",
          "description": "從 PDF 提取文字區塊和視覺元素，用 Gemini 摘要圖片，並建立 RAG 索引",
          "authentication": true,
          "request": {
            "contentType": "multipart/form-data",
            "parameters": {
              "file": {
                "type": "file",
                "required": true,
                "description": "PDF 檔案"
              }
            }
          },
          "response": {
            "type": "ExtractedDocument",
            "schema": {
              "doc_id": {
                "type": "string",
                "format": "uuid",
                "description": "文件 UUID"
              },
              "user_id": {
                "type": "string",
                "description": "使用者 ID"
              },
              "text_chunks": {
                "type": "array",
                "description": "文字區塊列表",
                "items": {
                  "page_number": "integer",
                  "content": "string (Markdown 格式)",
                  "chunk_id": "string"
                }
              },
              "visual_elements": {
                "type": "array",
                "description": "視覺元素列表 (圖表、公式等)",
                "items": {
                  "id": "string (uuid)",
                  "type": "table | figure | formula",
                  "page_number": "integer",
                  "image_path": "string",
                  "bbox": "[x1, y1, x2, y2]",
                  "original_text": "string | null",
                  "summary": "string (Gemini 生成的摘要)"
                }
              },
              "processed_at": {
                "type": "string",
                "format": "datetime",
                "description": "處理時間"
              }
            }
          },
          "pipeline": [
            "Phase 1: 使用 PaddleOCR 提取文字區塊和視覺元素",
            "Phase 2: 使用 Gemini 為視覺元素生成摘要",
            "Phase 3: 將所有內容建立 FAISS 向量索引"
          ],
          "errorResponses": {
            "400": "File must be a PDF",
            "500": "Extraction failed | File processing error"
          },
          "flutterExample": {
            "code": "Future<ExtractedDocument> extractFromPdf(File pdfFile, String accessToken) async {\n  final uri = Uri.parse('$baseUrl/multimodal/extract');\n  final request = http.MultipartRequest('POST', uri)\n    ..headers['Authorization'] = 'Bearer $accessToken'\n    ..files.add(await http.MultipartFile.fromPath(\n      'file',\n      pdfFile.path,\n      contentType: MediaType('application', 'pdf'),\n    ));\n  \n  final response = await request.send();\n  if (response.statusCode == 200) {\n    final body = await response.stream.bytesToString();\n    return ExtractedDocument.fromJson(jsonDecode(body));\n  }\n  throw Exception('Extraction failed');\n}"
          },
          "reactExample": {
            "code": "async function extractFromPdf(file: File, accessToken: string): Promise<ExtractedDocument> {\n  const formData = new FormData();\n  formData.append('file', file);\n  \n  const response = await fetch(`${baseUrl}/multimodal/extract`, {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${accessToken}` },\n    body: formData,\n  });\n  \n  if (!response.ok) throw new Error('Extraction failed');\n  return response.json();\n}"
          },
          "notes": [
            "處理時間較長，建議設定 60 秒以上的 timeout",
            "visual_elements 中的 image_path 為伺服器端路徑，前端無法直接存取",
            "summary 欄位由 Gemini Vision 自動生成，描述視覺元素的內容",
            "提取完成後可使用 /rag/ask 查詢該文件的內容"
          ]
        },

        "delete": {
          "path": "/multimodal/file/{doc_id}",
          "method": "DELETE",
          "description": "刪除多模態文件及其所有相關資料",
          "authentication": true,
          "request": {
            "pathParameters": {
              "doc_id": {
                "type": "string",
                "format": "uuid",
                "required": true,
                "description": "文件 UUID"
              }
            }
          },
          "response": {
            "type": "object",
            "example": {
              "status": "success",
              "message": "Multimodal document deleted successfully"
            }
          },
          "cleanupSteps": [
            "1. 從 FAISS 向量索引中移除 (文字區塊 + 視覺摘要)",
            "2. 刪除實體檔案 (原始 PDF + 裁切的圖片)"
          ],
          "flutterExample": {
            "code": "Future<void> deleteMultimodalDoc(String docId, String accessToken) async {\n  final response = await http.delete(\n    Uri.parse('$baseUrl/multimodal/file/$docId'),\n    headers: {'Authorization': 'Bearer $accessToken'},\n  );\n  if (response.statusCode != 200) throw Exception('Delete failed');\n}"
          }
        }
      }
    }
  },

  "schemas": {
    "AnswerResponse": {
      "description": "RAG 問答回應",
      "fields": {
        "question": { "type": "string", "description": "原始問題" },
        "answer": { "type": "string", "description": "AI 生成的答案" },
        "sources": { "type": "array[string]", "description": "參考的文件 ID 列表" }
      }
    },
    "ResearchResponse": {
      "description": "深度研究回應",
      "fields": {
        "question": { "type": "string" },
        "summary": { "type": "string", "description": "研究摘要" },
        "detailed_answer": { "type": "string", "description": "詳細研究報告" },
        "sub_tasks": { "type": "array[SubTaskResponse]" },
        "all_sources": { "type": "array[string]" },
        "confidence": { "type": "number", "range": "0.0-1.0" }
      }
    },
    "SubTaskResponse": {
      "description": "子任務回應",
      "fields": {
        "id": { "type": "integer" },
        "question": { "type": "string" },
        "answer": { "type": "string" },
        "sources": { "type": "array[string]" }
      }
    },
    "ExtractedDocument": {
      "description": "多模態提取結果",
      "fields": {
        "doc_id": { "type": "string (uuid)" },
        "user_id": { "type": "string" },
        "text_chunks": { "type": "array[TextChunk]" },
        "visual_elements": { "type": "array[VisualElement]" },
        "processed_at": { "type": "datetime" }
      }
    },
    "TextChunk": {
      "fields": {
        "page_number": { "type": "integer" },
        "content": { "type": "string", "description": "Markdown 格式內容" },
        "chunk_id": { "type": "string" }
      }
    },
    "VisualElement": {
      "fields": {
        "id": { "type": "string (uuid)" },
        "type": { "type": "enum", "values": ["table", "figure", "formula"] },
        "page_number": { "type": "integer" },
        "image_path": { "type": "string" },
        "bbox": { "type": "array[int]", "description": "[x1, y1, x2, y2] 座標" },
        "original_text": { "type": "string | null" },
        "summary": { "type": "string | null", "description": "Gemini 生成的摘要" }
      }
    }
  },

  "errorHandling": {
    "httpStatusCodes": {
      "200": "成功",
      "400": "請求錯誤 (無效的輸入、不支援的檔案類型)",
      "401": "未授權 (缺少或無效的 Token)",
      "403": "禁止存取 (Token 有效但權限不足)",
      "404": "找不到資源 (文件不存在)",
      "422": "驗證錯誤 (Pydantic 驗證失敗)",
      "500": "伺服器錯誤 (處理失敗、服務不可用)"
    },
    "errorResponseFormat": {
      "example": {
        "detail": "Error message describing what went wrong"
      }
    },
    "recommendedHandling": {
      "flutter": "try {\n  await apiCall();\n} on http.ClientException catch (e) {\n  // Network error\n} catch (e) {\n  final statusCode = (e as dynamic).statusCode;\n  switch (statusCode) {\n    case 401: // Show login dialog\n    case 404: // Show not found message\n    default: // Show generic error\n  }\n}",
      "react": "try {\n  await apiCall();\n} catch (error) {\n  if (error.response?.status === 401) {\n    // Redirect to login\n  } else if (error.response?.status === 404) {\n    // Show not found\n  } else {\n    // Show generic error toast\n  }\n}"
    }
  },

  "bestPractices": {
    "flutter": [
      "使用 Riverpod 或 BLoC 管理 API 狀態",
      "建立獨立的 Repository 層封裝 API 呼叫",
      "使用 Freezed 生成不可變的資料類別",
      "檔案上傳時顯示進度指示器",
      "妥善處理網路錯誤並顯示適當的使用者提示",
      "使用 secure storage 安全儲存 access token",
      "Token 過期時自動使用 refresh token 更新"
    ],
    "react": [
      "使用 React Query 或 SWR 管理伺服器狀態",
      "建立 API client 統一處理 headers 和錯誤",
      "使用 TypeScript 定義完整的 API 類型",
      "檔案上傳時追蹤進度 (使用 XMLHttpRequest 或 axios)",
      "實作 retry 機制處理暫時性錯誤",
      "使用 Context 或 Zustand 管理認證狀態"
    ],
    "general": [
      "所有耗時操作（上傳、翻譯、研究）都應設定適當的 timeout (建議 60-120 秒)",
      "顯示載入指示器告知使用者處理中",
      "回傳的 sources 可用於實作「資料來源」功能，讓使用者追溯答案來源",
      "doc_id 應妥善儲存，用於後續查詢和刪除操作",
      "建議實作離線快取機制，提升使用者體驗"
    ]
  },

  "exampleWorkflows": {
    "uploadAndAsk": {
      "description": "上傳 PDF 後進行問答",
      "steps": [
        "1. 呼叫 POST /pdfmd/ocr 上傳 PDF",
        "2. 儲存回傳的 doc_id (從 response header 或 Supabase 查詢)",
        "3. 呼叫 GET /rag/ask?question=xxx&doc_ids={doc_id} 針對該文件提問",
        "4. 顯示答案和來源"
      ]
    },
    "multimodalResearch": {
      "description": "多模態提取後進行深度研究",
      "steps": [
        "1. 呼叫 POST /multimodal/extract 提取 PDF 內容",
        "2. 顯示提取結果 (text_chunks + visual_elements)",
        "3. 呼叫 POST /rag/research 進行深度研究",
        "4. 顯示研究報告和子任務分析"
      ]
    },
    "imageTranslation": {
      "description": "翻譯圖片中的文字",
      "steps": [
        "1. 讓使用者選擇或拍攝圖片",
        "2. 呼叫 POST /imagemd/translate_image",
        "3. 將回傳的圖片顯示給使用者",
        "4. 提供下載或分享選項"
      ]
    }
  },

  "metadata": {
    "generatedAt": "2025-12-12T11:45:00+08:00",
    "generatedBy": "Antigravity Agent",
    "targetAudience": ["Flutter Mobile Developer", "Flutter Web Developer", "React Developer", "Frontend AI Agent"],
    "language": "zh-TW (繁體中文)"
  }
}
